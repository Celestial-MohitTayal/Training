//---------JS Basic refresher (Data Types, loops, conditions, objects, classes)--------------------->
    Data Types
        JavaScript has seven primitive data types and one complex data type:

        Primitive Data Types:

            Number:     Represents both integer and floating-point numbers.
            String:     A sequence of characters enclosed in single or double quotes.
            Boolean:    Logical values, either true or false.
            Null:       Represents the absence of an object.
            Undefined:  Indicates that a variable has been declared but not assigned a value.
            Symbol:     A unique identifier useful for property keys.
            BigInt:     Represents whole numbers larger than 2<sup>53</sup> - 1.


        Complex Data Type:

            Object: A collection of properties, each with a key and a value.
                
    --------------------------------------
    Loops
        Loops allow you to execute a block of code multiple times:

        For Loop:
            for (let i = 0; i < 5; i++) {
                console.log(i);
            }

        While Loop:
            let i = 0;
            while (i < 5) {
              console.log(i);
              i++;
            }

        Do...While Loop:
            let i = 0;
            do {
              console.log(i);
              i++;
            } while (i < 5);

    -----------------------------------------
    Conditional Statements:
        Conditional statements control the flow of execution based on conditions:

        If...Else Statement:
            let age = 18;
            if (age >= 18) {
              console.log("You are an adult.");
            } else {
              console.log("You are a minor.");
            }

        Switch Statement:
            let day = "Monday";
            switch (day) {
              case "Monday":
                console.log("Start of the workweek.");
                break;
              case "Friday":
                console.log("End of the workweek.");
                break;
              default:
                console.log("Midweek day.");
            }

    -----------------------------------------------
    Objects:
        Objects are central to JavaScript and are used to store collections of data and functions:
            const person = {

                firstName: "John",
                lastName: "Doe",
                age: 30,

                greet: function() {
                    console.log(`Hello, ${this.firstName} ${this.lastName}!`);
                }
            };

            person.greet(); // Outputs: Hello, John Doe!
    
    ---------------------------------------------------
    Classes:
        Introduced in ES6, classes provide a blueprint for creating objects:
            class Person {
                constructor(firstName, lastName, age) {
                    this.firstName = firstName;
                    this.lastName = lastName;
                    this.age = age;
                }
                greet() {
                    console.log(`Hello, ${this.firstName} ${this.lastName}!`);
                }
            }
            const john = new Person("John", "Doe", 30);
            john.greet(); // Outputs: Hello, John Doe!

        
        Classes simplify the process of creating objects and handling inheritance, promoting a more organized code structure.


<-------------------------[Advance data types] Maps / Sets--------------------------->

    Maps:
        A Map is a collection of key-value pairs where both keys and values can be of any data type. It maintains the insertion order of the elements and provides efficient access based on the key.
            
            let myMap = new Map();
            
            // Adding key-value pairs
            myMap.set('name', 'John');
            myMap.set('age', 25);
            
            // Accessing values by key
            console.log(myMap.get('name'));     // Outputs: John
            
            // Checking if a key exists
            console.log(myMap.has('age'));      // Outputs: true
            
            // Deleting a key-value pair
            myMap.delete('age');
            
            // Getting the size of the Map
            console.log(myMap.size);            // Outputs: 1
            
            // Iterating over a Map
            for (let [key, value] of myMap) {
              console.log(`${key}: ${value}`);
            }

        Maps are particularly useful when you need to store dynamic key-value pairs or when the keys are not guaranteed to be strings.
    
    -----------------------------------------------
    Sets:
        A Set is a collection of unique values. Unlike an array, a Set does not allow duplicates and is great when you need to ensure the uniqueness of elements.

            let mySet = new Set();

            // Adding elements to the Set
            mySet.add(1);
            mySet.add(5);
            mySet.add(5); // Duplicate, won't be added

            // Checking if an element exists
            console.log(mySet.has(1)); // Outputs: true
            console.log(mySet.has(10)); // Outputs: false

            // Getting the size of the Set
            console.log(mySet.size); // Outputs: 2

            // Deleting an element
            mySet.delete(5);

            // Iterating over a Set
            for (let value of mySet) {
              console.log(value);
            }
        
    ------------------------------------------
    Key Differences Between Maps and Sets:
        Map:
            Stores key-value pairs.
            Keys are unique, and values can be duplicated.
            Allows access to values using keys.

        Set:
            Stores only unique values (no duplicates).
            Does not have key-value pairs—just values.
            Useful for ensuring the uniqueness of data.

    -------------------------------------------
    Maps: Detailed Examples and Use Cases:

        Use Case: Storing Metadata for Objects
            Maps allow you to store metadata for objects without modifying the objects themselves, making it a great solution for cases where you need dynamic properties.

                let user1 = { name: 'John' };
                let user2 = { name: 'Jane' };

                let userMeta = new Map();
                userMeta.set(user1, { role: 'admin', isActive: true });
                userMeta.set(user2, { role: 'user', isActive: false });

                console.log(userMeta.get(user1)); // Outputs: { role: 'admin', isActive: true }
            
            Why use a Map?
            The keys can be objects (in this case, user1 and user2), something that isn't possible with regular objects in JavaScript.

        --------------
        Use Case: Counting Frequency of Elements
            Maps can be used for counting occurrences of elements efficiently, which is useful in situations like analyzing text or data.
                
                const countWords = (text) => {
                    let wordMap = new Map();
                    let words = text.split(' ');

                    for (let word of words) {
                        word = word.toLowerCase();
                        if (wordMap.has(word)) {
                        wordMap.set(word, wordMap.get(word) + 1);
                        } else {
                        wordMap.set(word, 1);
                        }
                    }
                    return wordMap;
                }

                console.log(countWords('hello Hello world world world'));
                // Outputs: Map { 'hello' => 2, 'world' => 3 }

            Using set() and get() methods makes this very efficient for storing and retrieving data without worrying about key types.

    ------------------------------------------------
    Sets: Detailed Examples and Use Cases
        Use Case: Removing Duplicates from Arrays
            If you have an array with duplicate values and need to remove duplicates, a Set is perfect for this.

                let numbers = [1, 2, 3, 3, 4, 5, 5, 6];
                let uniqueNumbers = [...new Set(numbers)];
                console.log(uniqueNumbers); // Outputs: [1, 2, 3, 4, 5, 6]

            A Set automatically ensures that all elements are unique, so you don’t have to write custom logic to remove duplicates.

        ----------------
        Use Case: Checking for Unique Values in Real-Time
            When you’re streaming data or processing elements in real-time and need to ensure that values are unique, Sets are very handy.
                
                let onlineUsers = new Set();

                // Adding users as they log in
                onlineUsers.add('user1');
                onlineUsers.add('user2');
                onlineUsers.add('user1'); // Won't be added again

                console.log(onlineUsers.size); // Outputs: 2
            
            No duplicates are allowed, and the performance for checking if a value exists is optimized.

        ----------------
        Use Case: Performing Set Operations (Intersection, Union, Difference)
            You can use Sets to perform common set operations like intersection, union, and difference, often useful in algorithms and data processing.
                
                let setA = new Set([1, 2, 3, 4]);
                let setB = new Set([3, 4, 5, 6]);

                // Intersection: Elements in both sets
                let intersection = new Set([...setA].filter(x => setB.has(x)));
                console.log(intersection); // Outputs: Set { 3, 4 }

                // Union: Elements in either set
                let union = new Set([...setA, ...setB]);
                console.log(union); // Outputs: Set { 1, 2, 3, 4, 5, 6 }

                // Difference: Elements in setA but not in setB
                let difference = new Set([...setA].filter(x => !setB.has(x)));
                console.log(difference); // Outputs: Set { 1, 2 }

            Set operations are easier and more efficient when you’re dealing with collections where uniqueness is important.

    ------------------------------------------
    When to Use Maps vs. Sets
    Use a Map when:
        You need key-value pairs.
        You need keys that aren’t necessarily strings (like objects or functions).
        You need to maintain the order of key insertions.

    Use a Set when:
        You need to store unique values.
        You need to remove duplicates or ensure uniqueness in a collection.
        You need to perform mathematical set operations like intersection or union.


<-----------------------[JS Basic] Array / Object methods, string methods, prototype---------------------->

    Array Methods:
        push(): Adds elements to the end of an array.
            let arr = [1, 2, 3];
            arr.push(4); // [1, 2, 3, 4]
        
        pop(): Removes and returns the last element of an array.
            arr.pop(); // 4, arr = [1, 2, 3]

        shift(): Removes and returns the first element.
            arr.shift(); // 1, arr = [2, 3]

        unshift(): Adds elements to the beginning of an array.
            arr.unshift(0); // [0, 2, 3]

        map(): Creates a new array with the result of calling a function on every element.
            let doubled = arr.map(x => x * 2); // [0, 4, 6]

        filter(): Creates a new array with all elements that pass the test.
            let filtered = arr.filter(x => x > 1); // [2, 3]

        reduce(): Executes a reducer function on each element to reduce the array to a single value.
            let sum = arr.reduce((acc, curr) => acc + curr, 0); // 5

        find(): Returns the first element that satisfies the condition.
            let found = arr.find(x => x > 2); // 3

        findIndex(): Returns the index of the first element that satisfies the condition.
            let index = arr.findIndex(x => x > 2); // 1

        slice(): Returns a shallow copy of a portion of an array.
            let sliced = arr.slice(1, 3); // [2, 3]

        splice(): Adds/removes elements from an array.
            arr.splice(1, 1, 10); // [0, 10, 3]

        concat(): Merges two or more arrays.
            let newArr = arr.concat([4, 5]); // [0, 10, 3, 4, 5]

    --------
    Use Case: Flattening arrays
        let nestedArr = [1, [2, [3, 4], 5]];
        let flatArr = nestedArr.flat(2); // [1, 2, 3, 4, 5]


    ------------------------------------------
    Object Methods
        Object.keys(): Returns an array of the object's property names.
            let obj = { a: 1, b: 2 };
            let keys = Object.keys(obj); // ['a', 'b']

        Object.values(): Returns an array of the object's property values.
            let values = Object.values(obj); // [1, 2]
        
        Object.entries(): Returns an array of the object's key-value pairs.
            let entries = Object.entries(obj); // [['a', 1], ['b', 2]]

        Object.assign(): Copies all properties from one or more source objects to a target object.
            let target = {};
            Object.assign(target, obj); // target = { a: 1, b: 2 }

        Object.freeze(): Freezes an object so that properties cannot be added, removed, or changed.
            Object.freeze(obj);
            obj.a = 10; // Will not change

        Object.seal(): Prevents new properties from being added but allows modification of existing properties.
            Object.seal(obj);
            obj.a = 10; // Works
            obj.c = 3;  // Will not be added

        Object.create(): Creates a new object with a specified prototype
            let parent = { role: 'admin' };
            let child = Object.create(parent);
            console.log(child.role); // 'admin'

    ---------
    Use Case: Cloning an object
        let cloned = Object.assign({}, obj); // Shallow copy of obj


    ----------------------------------------------
    String Methods:
        charAt(): Returns the character at the specified index.
            let str = 'Hello';
            console.log(str.charAt(1)); // 'e'
        
        includes(): Checks if the string contains the specified substring.
            console.log(str.includes('ll')); // true

        indexOf(): Returns the index of the first occurrence of a substring.
            console.log(str.indexOf('l')); // 2

        slice(): Extracts a section of a string.
            let part = str.slice(1, 4); // 'ell'
        
        split(): Splits a string into an array of substrings.
            let parts = str.split(''); // ['H', 'e', 'l', 'l', 'o']

        replace(): Replaces the matched substring with a new string.
            let newStr = str.replace('Hello', 'Hi'); // 'Hi'

        toLowerCase() / toUpperCase(): Converts the string to lowercase/uppercase.
            let lower = str.toLowerCase(); // 'hello'
            let upper = str.toUpperCase(); // 'HELLO'

        trim(): Removes whitespace from both sides of a string.
            let spaced = '   Hello   ';
            console.log(spaced.trim()); // 'Hello'

    ------------
    Use Case: Capitalizing the first letter of a string
        let capitalized = str.charAt(0).toUpperCase() + str.slice(1).toLowerCase(); // 'Hello'


    ---------------------------------------------------
    Prototypes
        JavaScript is prototype-based, meaning objects can inherit properties and methods from other objects via prototypes.
            function Person(name, age) {
              this.name = name;
              this.age = age;
            }

            Person.prototype.greet = function() {
              console.log(`Hello, my name is ${this.name}.`);
            };

            let john = new Person('John', 30);
            john.greet(); // Outputs: Hello, my name is John.
        
        Prototype Chain: When you try to access a property on an object, JavaScript checks if the object has that property. If not, it looks up the prototype chain to see if the property exists on the parent (or parent's parent, etc.).

    -----------
    Use Case: Extending Prototypes
        You can extend prototypes to add methods to existing constructors, allowing all instances to share these methods:

            Array.prototype.last = function() {
              return this[this.length - 1];
            };

            let arr = [1, 2, 3];
            console.log(arr.last()); // Outputs: 3

    ----------------------------------------------
    Key Takeaways:
        ->Array methods help in manipulating lists.
        ->Object methods help in managing key-value pairs and handling object properties.
        ->String methods are useful for manipulating text.
        ->Prototypes provide a mechanism for object inheritance, allowing method sharing across instances.


<------------------------------------[JS Basic] Hoisting / Closures.-------------------------------------->

    Hoisting
        Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution. This means that even if you define a variable or function after you use it, JavaScript "hoists" its declaration to the top of the scope.

        Key Points about Hoisting:
            Variable declarations (using var) are hoisted, but their assignments are not.
            Function declarations are hoisted entirely (both the function name and its implementation), but function expressions are not.
            let and const are hoisted as well, but they are in a "temporal dead zone" until they are declared.

        Example: Variable Hoisting with var
            console.log(x);  // Outputs: undefined (not an error)
            var x = 5;
            console.log(x);  // Outputs: 5

            What happens: In the first console.log, x is hoisted, but its value isn't assigned yet, so JavaScript assigns undefined to x until the assignment (x = 5) occurs.
            
            // Behind the scenes (hoisting effect):
            var x;
            console.log(x);  // undefined
            x = 5;
            console.log(x);  // 5
        -------
        Example: Function Declaration Hoisting
            greet(); // Outputs: Hello!
            function greet() {
              console.log("Hello!");
            }

            What happens: The entire greet() function is hoisted to the top of the scope, so it can be called before its definition.
        --------
        Function Expression (not hoisted)
            greet(); // Error: greet is not a function
            var greet = function() {
              console.log("Hello!");
            };

            What happens: Here, only the declaration var greet is hoisted, not the assignment (which is the actual function). Thus, calling greet() before the function assignment leads to an error.
        ---------
        Hoisting with let and const
            console.log(y); // ReferenceError: Cannot access 'y' before initialization
            let y = 10;

            Variables declared with let and const are hoisted, but they remain uninitialized until the actual line where they are declared. This period before initialization is known as the temporal dead zone.

    --------------------------------------------------
    Closures
        A closure is a function that "remembers" the environment in which it was created. It allows the function to access variables from its outer scope even after the outer function has returned.

        How Closures Work:
        When a function is defined inside another function, it forms a closure. The inner function has access to the variables and parameters of the outer function, even after the outer function has finished executing.
        
        Example: Basic Closure
            function outer() {
              let outerVar = 'I am from outer';

              function inner() {
                console.log(outerVar); // Can access outerVar from outer scope
              }

              return inner;
            }

            const closureFunc = outer();
            closureFunc();  // Outputs: 'I am from outer'

            In this example, even though outer() has finished executing, the inner() function still remembers the variable outerVar because it forms a closure.
        ---------
        Practical Use Case: Creating Private Variables
            Closures can be used to simulate private variables (data hiding), which is common in object-oriented programming.
                
                function createCounter() {
                  let count = 0; // private variable

                  return function() {
                    count++;
                    return count;
                  };
                }

                const counter = createCounter();
                console.log(counter()); // Outputs: 1
                console.log(counter()); // Outputs: 2

                Explanation: The variable count is "trapped" in the closure of the returned function. No other code outside of createCounter can access or modify count directly, creating a form of encapsulation.
        ------------
        Example: Closures in Loops
            Closures often come into play when dealing with asynchronous code or loops.
            
            for (var i = 1; i <= 3; i++) {
              setTimeout(function() {
                console.log(i); // Outputs: 4, 4, 4 (because `i` is hoisted and shared)
              }, 1000);
            }

            In this case, due to the closure, the console.log(i) inside the setTimeout references the same variable i, which after the loop ends is 4.
        -------------
        Solution using closures with let (which creates a new scope per iteration):
            for (let i = 1; i <= 3; i++) {
              setTimeout(function() {
                console.log(i); // Outputs: 1, 2, 3
              }, 1000);
            }

    ---------------------------------------------------
    Key Takeaways:
    Hoisting:
        Variables declared with var are hoisted to the top of their scope but initialized with undefined.
        Function declarations are hoisted, but function expressions are not.
        let and const are hoisted but enter a "temporal dead zone" and are not accessible until declared.
    Closures:
        A closure is a function that "remembers" its outer environment, even after the outer function has finished execution.
        Useful for creating private variables or maintaining state across multiple function calls.
        Important in asynchronous operations like timers or callbacks, where you need to preserve the value of variables over time.


<---------------------------[JS Basic] this keyword with object and new arrow fn-------------------------->

    The this Keyword in JavaScript
        The this keyword in JavaScript refers to the context in which a function is executed. Its value can vary depending on how a function is called. Understanding this is crucial for working with objects, methods, and constructors.

        this in Object Methods
            When a function is called as a method of an object, this refers to the object that the method is called on.
                
                const person = {
                  name: 'Alice',
                  greet: function() {
                    console.log(`Hello, my name is ${this.name}`);
                  }
                };

                person.greet(); // Outputs: Hello, my name is Alice

            Explanation: In this example, this.name refers to the name property of the person object.
        ---------
        this in Regular Functions
            In regular functions (not methods), this refers to the global object in non-strict mode (window in browsers) or undefined in strict mode.
                
                function showThis() {
                  console.log(this);
                }

                showThis(); // In non-strict mode: Outputs: Window {...} (or global object)
                // In strict mode: Outputs: undefined
            
            -> Using strict method

                "use strict";
                function showThis() {
                  console.log(this);
                }
                
                showThis(); // Outputs: undefined
        -----------
        this in Constructor Functions
            In constructor functions (functions used with the new keyword), this refers to the newly created object.
                
                function Person(name) {
                  this.name = name;
                }

                const john = new Person('John');
                console.log(john.name); // Outputs: John
           
            Explanation: Here, this inside the Person function refers to the new instance of Person being created.
        ------------
        this with Event Handlers
            In event handlers, this refers to the element that fired the event.

                const button = document.getElementById('myButton');
                button.addEventListener('click', function() {
                  console.log(this); // Outputs: <button id="myButton">...</button>
                });

    ---------------------------------------------------------------
    Arrow Functions and this
        Arrow functions differ from regular functions in how they handle this. They do not have their own this context; instead, they inherit this from the enclosing lexical scope (the surrounding function or global context).

        Arrow Function Example:
            const person = {
              name: 'Bob',
              greet: function() {
                const arrowFunction = () => {
                  console.log(`Hello, my name is ${this.name}`);
                };
                arrowFunction();
              }
            };

            person.greet(); // Outputs: Hello, my name is Bob

            Explanation: In this case, this inside the arrowFunction refers to the person object, because the arrow function captures this from its lexical scope, which is the greet method of the person object.
        -----------
        Arrow Functions in Regular Functions
            When an arrow function is defined inside a regular function, this still refers to the outer context.

                function showThis() {
                  const arrowFunc = () => {
                    console.log(this);
                  };
                  arrowFunc();
                }

                showThis(); // In non-strict mode: Outputs: Window {...}

                Explanation: Here, this inside arrowFunc refers to the global object in non-strict mode, as it inherits the value of this from the showThis function.

    -----------------------------------------------------
        Key Points to Remember
            In object methods, this refers to the object the method is called on.
            In regular functions, this refers to the global object (or undefined in strict mode).
            In constructor functions, this refers to the new instance created.
            In event handlers, this refers to the element that triggered the event.
            Arrow functions do not bind their own this; they inherit it from the surrounding context.
        
        Summary
            Understanding the behavior of this is essential for writing effective JavaScript, especially when working with objects, constructors, and event handling. Arrow functions provide a more predictable behavior regarding this, making them useful in many scenarios where you want to maintain the context.


<----------------------------[JS Basic] Lexical environment / Execution stack----------------------------->
    1. Lexical Environment
        A lexical environment is a structure that holds variable bindings (i.e., identifiers and their values) for a particular scope. It consists of:

        Environment Record: A data structure that stores variables (bindings).
        Outer Lexical Environment Reference: A reference to the lexical environment of the outer scope.
        How Lexical Environments Work: Whenever a function is created, a new lexical environment is formed. This environment retains the variables defined within it as well as a reference to its outer environment. This is crucial for closures, as inner functions can access variables from their outer lexical environment.

        Example: Lexical Environment:
            function outerFunction() {
              let outerVar = 'I am from outer';

              function innerFunction() {
                console.log(outerVar); // Accessing outerVar from the outer lexical environment
              }

              innerFunction();
            }

            outerFunction(); // Outputs: I am from outer

            Explanation: In this example, innerFunction has access to outerVar because it is within the same lexical environment created by outerFunction.

    ----------------------------------------
    2. Execution Stack (Call Stack)
        The execution stack, often referred to as the call stack, is a stack data structure that stores information about the active execution contexts in JavaScript. Each time a function is called, a new execution context is created and pushed onto the stack.

        Components of Execution Context:
            Variable Object: Holds variables and function declarations for the context.
            Scope Chain: Consists of the current context's variable object and references to outer contexts (lexical environments).
            this Binding: Refers to the current execution context.
            
        How Execution Stack Works:
            The execution stack follows the Last In, First Out (LIFO) principle.
            When a function is called, a new execution context is created and pushed onto the stack.
            When the function completes, its execution context is popped off the stack.

        Example: Execution Stack
            function firstFunction() {
              console.log('First function called');
              secondFunction(); // Call to the second function
            }

            function secondFunction() {
              console.log('Second function called');
            }

            firstFunction();

        Execution Steps:
        The firstFunction is called and its context is pushed onto the stack.
        Inside firstFunction, secondFunction is called, so its context is pushed onto the stack.
        secondFunction completes and its context is popped off the stack.
        Control returns to firstFunction, which then completes and is also popped off the stack.

        Execution Stack Visualization:

            When firstFunction is called:
                Call Stack
                [firstFunction]
            
            When secondFunction is called from within firstFunction:
                Call Stack
                [secondFunction]
                [firstFunction]

            After secondFunction completes:
                Call Stack
                [firstFunction]
            
    -----------------------------------------------------
    Key Takeaways
    Lexical Environment:
        Provides the context for variable resolution.
        Comprised of environment records and outer references.
        Closures rely on lexical environments to access outer variables.

    Execution Stack:
        Manages the order of function calls and their contexts.
        Follows a LIFO structure.
        Each function call creates a new execution context that gets pushed onto the stack.


<-------------------------------------Callbacks / asyn-await---------------------------------------------->




    
